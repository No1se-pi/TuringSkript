import math # импорт библиотеки с математикой для дальнейших мат. операций
import random #Для генерации случайных чис
import time # подключаем модуль time

# фиксируем время старта работы кода
start = time.time()



# Вывод сообщений для удобства пользователя
print("Вы хотите зашифровать или разшифровать сообщение?")
print("Если зашифровать, введите 1")
print("Если разшифровать введите 2", "\n")

key = 0 # Итоговый ключ

key_len_messege=0
key_phone=0
key_privat=0

# Счётчики
counter = 0
counter2 = 0 
#__________________________________________________________________________________________________________________________________________
#print("\n") - тупо для пробелов
#__________________________________________________________________________________________________________________________________________
messege_list = [] # Сюда будет закидываться всё сообщение, но по буквам
code_list = []
#__________________________________________________________________________________________________________________________________________
# Алфавит для дальнейшей шифрации
alphabet = [
    ' ', 'а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н',
    'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я',
    'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
    "0","1","2","3","4","5","6","7","8","9",",",".","!","-"
]

# а1 б2 в3 г4 д5 е6 ё7 ж8 з9 и10 й11 к12 л13 м14 н15 о16 п17 р18 с19 т20 у21 ф22 х23 ц24 ч25 ш26 щ27 ъ28 ы29 ь30 э31 ю32 я33 
# " " - 0; 0 - 60;1 - 61;2 - 62;3 - 63;4 - 64;5 - 65;6 - 66;7 - 67;8 - 68;9 - 69; 
# a34 b35 c36 d37 e38 f39 g40 h41 i42 j43 k44 L45 m46 n47 o48 p49 q50 r51 s52 t53 u54 v55 w56 x57 y58 z59

#__________________________________________________________________________________________________________________________________________
# Функция Алгоритма Венрнама
def vernam(messege, key): # На вход дожны податься сообщение и ключ 
    messege_and_key=[] # Массив для ключа и сообщения 
    code=[] # Итоговый код

    cod="" #Итоговый код будет в этой переменной
    counter_vernam=0 # Счётчик для алгоритма

#сообщение в бинарном коде
    for mes2bin in range(len(messege)): # Сообщение по отдельности в массив
        messege_and_key.append(messege[counter_vernam]) # В массив добавляеться x элемент сообщения
        counter_vernam+=1 # Увеличение индекса для перехода на след. букву

#добавления в массив ключа
    counter_vernam=0 # Обнуление счётчика
    for key2bin in range(len(messege)): # Ключ по отдельности в массив
        messege_and_key.append(key[counter_vernam]) # Сообщение по отдельности в массив
        counter_vernam+=1 # В массив добавляеться x элемент ключа

#Операцмя исключающего или, с ключом и сообщением.  
    counter_vernam=0 # Обнуление счётчика
    for exclusive_or in range(len(messege)): # Цикл для операции исключающего или. Выполняеться (длина сообщения раз)
        code.append(int(messege_and_key[counter_vernam])^int(messege_and_key[counter_vernam+(len(key))])) # ^ - это исключающее или. 
        counter_vernam+=1 # В массив добавляеться x элемент шифра

    #превращения массива в сообщение
    counter_vernam=0
    for arr2mes in range(len(messege)):   
        cod=cod+str(code[counter_vernam])
        counter_vernam+=1
        
    return(cod)
#__________________________________________________________________________________________________________________________________________
# Функция для создания ключа из номера телефона
def phone_function(phone_num):
    if phone_num[0]=="+": # Проверка на наличие плюса
        phone_num=phone_num[1::] # Если есть, то удалить его 
    counter=0 # Создание счётчика
    phone_list=[] # Создание массива для номера телефона

    # Поэлиментное добавление цифр в массив
    for phone_len in range(len(phone_num)):
        phone_list.append(int(phone_num[counter]))
        counter+=1
    phone_sum=sum(phone_list) #Сумма всех чисел в массиве
    phone_key=((bin(phone_sum))[2::]) # Биннирование суммы числа

    if len(phone_key)!=7: # Добавление ведущих нулей
        while len(phone_key)!=7: 
            phone_key="0"+str(phone_key)
    return(phone_key)
#__________________________________________________________________________________________________________________________________________
# Превращение цифр в бинарный код
def binning(messege, counter):
    code_bin=[]
    for binnin in range(len(messege)):
        bin_num=str(bin(messege[counter]))
        bin_num=bin_num[2:]
        if len(bin_num)<7:
            while len(bin_num)!=7:
                bin_num="0"+bin_num
            code_bin.append(bin_num)
        else:
            code_bin.append(bin_num)
        counter+=1
    return(code_bin)
#__________________________________________________________________________________________________________________________________________

# Пользователь выбирает в каком режиме будет работать программа
choise = int(input("Выберите: ")) 

#__________________________________________________________________________________________________________________________________________

# ШИФРОВАНИЕ
if choise == 1:
    messege = input("Введите сообщение, которое нужно зашифровать: ")
    print("\n")
    messege_size = len(messege)
    
    phone_num = "+79264680844"
    print("\n")   
#__________________________________________________________________________________________________________________________________________     
    # Делает сообщение по отдельности 
    for mes_list in range(messege_size): # Создание цикла, который работает столько раз, сколько символов в сообщении
        messege_list.append(messege[counter]) # Добавление символов в массив
        counter += 1 # Увеличение счётчика
    print(*messege_list)  # Тест
    
    counter = 0 # Обнуление счётчика 
#__________________________________________________________________________________________________________________________________________ 
    # Цифровизация
    for digitaling in range(messege_size):  # Цикл по количеству символов в сообщении
        # Находим индекс буквы в алфавите и добавляем его в code_list
        if messege_list[digitaling].lower() in alphabet:  # Проверяем, что символ есть в алфавите
            index = alphabet.index(messege_list[digitaling].lower())  # Индекс буквы в алфавите
            code_list.append(index)  # Добавляем индекс в список

    print("Зашифрованное сообщение:", code_list)  # Тест
#__________________________________________________________________________________________________________________________________________ 
    code=binning(code_list, counter)
    print(f"Биннированный code_list {code}")

    key_phone=phone_function(phone_num)
    print(f"Ключ из номера телефона: {key_phone}")
#__________________________________________________________________________________________________________________________________________   

    #print("\n")
    #print("\n")
    #code=vernam(code, key_phone)
    #print(f"Алгоритм вернама: {code}")

#__________________________________________________________________________________________________________________________________________   
# ДЕШИФРОВАНИЕ   
elif choise == 2:
    messege = input("Введите сообщение, которое нужно дешифровать: ")
    print("\n")
#__________________________________________________________________________________________________________________________________________   
# Вывод сообщения об ошибке пользователя   
else:
    print("Введено неверное значение!")
#__________________________________________________________________________________________________________________________________________

#__________________________________________________________________________________________________________________________________________
print("\n")
finish = time.time()

# вычитаем время старта из времени окончания и получаем результат в миллисекундах
res = finish - start
res_msec = res * 1000
print('Время работы в миллисекундах: ', res_msec)